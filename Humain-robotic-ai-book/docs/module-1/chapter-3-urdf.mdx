---
title: "Understanding URDF for Humanoid Robots"
sidebar_position: 5
description: Learn URDF (Unified Robot Description Format) for defining humanoid robot structure, links, joints, and kinematics for ROS 2 simulation and visualization
keywords: [ros2, urdf, robot description, links, joints, humanoid, kinematics, xml, robot model]
---

# Understanding URDF for Humanoid Robots

## Learning Objectives

By the end of this chapter, you will be able to:

- **Explain** what URDF is and why it's essential for robot systems
- **Identify** links, joints, and their relationships in robot structures
- **Create** basic URDF files for simple humanoid structures
- **Visualize** URDF models using RViz2
- **Understand** the difference between visual and collision geometry

**Estimated Time**: 60-90 minutes

---

## Prerequisites

- **Chapters 1-2**: ROS 2 nodes, topics, and services
- **XML Basics**: Understanding of XML tags and attributes
- **3D Geometry**: Basic understanding of coordinate systems (x, y, z, roll, pitch, yaw)
- **ROS 2 Tools**: Familiarity with RViz2 (visualization tool)

---

## What is URDF?

**URDF (Unified Robot Description Format)** is an XML-based format for describing robot structure. It defines:

- **Links**: Rigid bodies (robot parts like torso, upper arm, forearm)
- **Joints**: Connections between links (revolute, prismatic, fixed)
- **Geometry**: 3D shapes for visualization and collision detection
- **Kinematics**: How parts move relative to each other

### Why URDF?

**Visualization**: Display robot in RViz2 and other tools
- See robot structure in 3D
- Debug joint configurations
- Plan motion trajectories

**Simulation**: Run robot in Gazebo, Isaac Sim, Unity
- Test algorithms without real hardware
- Simulate sensors (cameras, LiDAR)
- Train AI policies safely

**Motion Planning**: Calculate inverse kinematics
- "Move hand to position X,Y,Z" → compute joint angles
- Path planning for navigation
- Collision avoidance

**Control**: Map joint commands to actuators
- Send angle/velocity commands to motors
- Read joint states from encoders
- Implement PID controllers

---

## URDF Structure Overview

```xml
<?xml version="1.0"?>
<robot name="humanoid_simple">

  <!-- Links: rigid bodies -->
  <link name="base_link">
    <!-- Visual geometry (what you see) -->
    <!-- Collision geometry (for physics) -->
    <!-- Inertial properties (mass, inertia) -->
  </link>

  <link name="torso">
    <!-- ... -->
  </link>

  <!-- Joints: connections between links -->
  <joint name="base_to_torso" type="fixed">
    <parent link="base_link"/>
    <child link="torso"/>
    <!-- Position and orientation -->
  </joint>

</robot>
```

**Key Concepts**:
- **Links** contain geometry, inertia, visual properties
- **Joints** define how links connect and move
- **Parent-Child Relationships** form a kinematic tree

---

## Links: Robot Parts

A **link** represents a rigid body. For humanoids:
- Torso, pelvis, head
- Upper arm, forearm, hand
- Thigh, shin, foot

### Basic Link Example

```xml
<link name="torso">

  <!-- Visual geometry (rendered in RViz/simulators) -->
  <visual>
    <origin xyz="0 0 0.25" rpy="0 0 0"/>
    <geometry>
      <box size="0.3 0.2 0.5"/>  <!-- width, depth, height in meters -->
    </geometry>
    <material name="blue">
      <color rgba="0 0 1 0.8"/>  <!-- RGBA: blue, 80% opaque -->
    </material>
  </visual>

  <!-- Collision geometry (used for physics simulation) -->
  <collision>
    <origin xyz="0 0 0.25" rpy="0 0 0"/>
    <geometry>
      <box size="0.3 0.2 0.5"/>
    </geometry>
  </collision>

  <!-- Inertial properties (mass and inertia matrix) -->
  <inertial>
    <origin xyz="0 0 0.25" rpy="0 0 0"/>
    <mass value="5.0"/>  <!-- kg -->
    <inertia ixx="0.1" ixy="0.0" ixz="0.0"
             iyy="0.1" iyz="0.0"
             izz="0.05"/>
  </inertial>

</link>
```

### Geometry Types

**Box**: Rectangular cuboid
```xml
<geometry>
  <box size="0.3 0.2 0.5"/>  <!-- x y z dimensions -->
</geometry>
```

**Cylinder**: Circular cylinder
```xml
<geometry>
  <cylinder radius="0.05" length="0.3"/>
</geometry>
```

**Sphere**: Perfect sphere
```xml
<geometry>
  <sphere radius="0.1"/>
</geometry>
```

**Mesh**: Custom 3D model (STL, DAE, OBJ)
```xml
<geometry>
  <mesh filename="package://robot_description/meshes/torso.stl" scale="0.001 0.001 0.001"/>
</geometry>
```

### Origin: Position and Orientation

```xml
<origin xyz="0 0 0.25" rpy="0 0 0"/>
```
- `xyz`: Position in meters (x, y, z)
- `rpy`: Rotation in radians (roll, pitch, yaw)

---

## Joints: Connecting Links

**Joints** define how links move relative to each other.

### Joint Types

**Fixed**: No movement (rigid connection)
```xml
<joint name="base_to_torso" type="fixed">
  <parent link="base_link"/>
  <child link="torso"/>
  <origin xyz="0 0 0" rpy="0 0 0"/>
</joint>
```

**Revolute**: Rotates around an axis (limited range)
```xml
<joint name="shoulder_pitch" type="revolute">
  <parent link="torso"/>
  <child link="upper_arm"/>
  <origin xyz="0 0.15 0.4" rpy="0 0 0"/>
  <axis xyz="0 1 0"/>  <!-- Rotate around Y-axis -->
  <limit lower="-1.57" upper="3.14" effort="50" velocity="2.0"/>
</joint>
```

**Continuous**: Rotates continuously (no limits)
```xml
<joint name="wheel_joint" type="continuous">
  <parent link="chassis"/>
  <child link="wheel"/>
  <axis xyz="0 1 0"/>
</joint>
```

**Prismatic**: Slides along an axis (linear motion)
```xml
<joint name="gripper_joint" type="prismatic">
  <parent link="hand"/>
  <child link="gripper_finger"/>
  <axis xyz="1 0 0"/>
  <limit lower="0" upper="0.05" effort="10" velocity="0.5"/>
</joint>
```

### Joint Limits

```xml
<limit lower="-1.57" upper="3.14" effort="50" velocity="2.0"/>
```
- `lower`/`upper`: Joint angle limits (radians for revolute, meters for prismatic)
- `effort`: Maximum force/torque (Newtons or Newton-meters)
- `velocity`: Maximum speed (rad/s or m/s)

---

## Simple Humanoid Example

Let's build a minimal humanoid upper body:
- Base (fixed to ground)
- Torso
- Head (revolute joint for neck)
- Two arms (shoulder joints)

### Complete URDF: simple_humanoid.urdf

```xml
<?xml version="1.0"?>
<robot name="simple_humanoid">

  <!-- Base link (world anchor) -->
  <link name="base_link"/>

  <!-- Torso -->
  <link name="torso">
    <visual>
      <origin xyz="0 0 0.3" rpy="0 0 0"/>
      <geometry>
        <box size="0.3 0.2 0.6"/>
      </geometry>
      <material name="gray">
        <color rgba="0.5 0.5 0.5 1.0"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 0.3" rpy="0 0 0"/>
      <geometry>
        <box size="0.3 0.2 0.6"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="10.0"/>
      <inertia ixx="0.5" ixy="0" ixz="0" iyy="0.5" iyz="0" izz="0.2"/>
    </inertial>
  </link>

  <joint name="base_to_torso" type="fixed">
    <parent link="base_link"/>
    <child link="torso"/>
  </joint>

  <!-- Head -->
  <link name="head">
    <visual>
      <origin xyz="0 0 0.1" rpy="0 0 0"/>
      <geometry>
        <sphere radius="0.12"/>
      </geometry>
      <material name="skin">
        <color rgba="0.9 0.7 0.6 1.0"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 0.1" rpy="0 0 0"/>
      <geometry>
        <sphere radius="0.12"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="2.0"/>
      <inertia ixx="0.02" ixy="0" ixz="0" iyy="0.02" iyz="0" izz="0.02"/>
    </inertial>
  </link>

  <joint name="neck" type="revolute">
    <parent link="torso"/>
    <child link="head"/>
    <origin xyz="0 0 0.6" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>  <!-- Rotate around Z-axis (yaw) -->
    <limit lower="-1.57" upper="1.57" effort="10" velocity="1.0"/>
  </joint>

  <!-- Left Arm -->
  <link name="left_upper_arm">
    <visual>
      <origin xyz="0 0 -0.15" rpy="0 0 0"/>
      <geometry>
        <cylinder radius="0.04" length="0.3"/>
      </geometry>
      <material name="skin">
        <color rgba="0.9 0.7 0.6 1.0"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 -0.15" rpy="0 0 0"/>
      <geometry>
        <cylinder radius="0.04" length="0.3"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="1.5"/>
      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.001"/>
    </inertial>
  </link>

  <joint name="left_shoulder" type="revolute">
    <parent link="torso"/>
    <child link="left_upper_arm"/>
    <origin xyz="0 0.15 0.5" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>  <!-- Pitch rotation -->
    <limit lower="-3.14" upper="3.14" effort="30" velocity="2.0"/>
  </joint>

  <!-- Right Arm (symmetric) -->
  <link name="right_upper_arm">
    <visual>
      <origin xyz="0 0 -0.15" rpy="0 0 0"/>
      <geometry>
        <cylinder radius="0.04" length="0.3"/>
      </geometry>
      <material name="skin">
        <color rgba="0.9 0.7 0.6 1.0"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 -0.15" rpy="0 0 0"/>
      <geometry>
        <cylinder radius="0.04" length="0.3"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="1.5"/>
      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.001"/>
    </inertial>
  </link>

  <joint name="right_shoulder" type="revolute">
    <parent link="torso"/>
    <child link="right_upper_arm"/>
    <origin xyz="0 -0.15 0.5" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <limit lower="-3.14" upper="3.14" effort="30" velocity="2.0"/>
  </joint>

</robot>
```

---

## Visualizing URDF in RViz2

### Step 1: Install Required Packages

```bash
sudo apt install ros-humble-joint-state-publisher-gui ros-humble-robot-state-publisher
```

### Step 2: Create Launch File

Create `display_humanoid.launch.py`:

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.substitutions import Command
import os
from ament_index_python.packages import get_package_share_directory


def generate_launch_description():
    # Path to URDF file
    urdf_file = os.path.join(
        os.getcwd(),
        'simple_humanoid.urdf'
    )

    # Read URDF file
    with open(urdf_file, 'r') as file:
        robot_desc = file.read()

    return LaunchDescription([
        # Robot State Publisher - publishes TF transforms
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            name='robot_state_publisher',
            output='screen',
            parameters=[{'robot_description': robot_desc}]
        ),

        # Joint State Publisher GUI - control joint angles
        Node(
            package='joint_state_publisher_gui',
            executable='joint_state_publisher_gui',
            name='joint_state_publisher_gui',
            output='screen'
        ),

        # RViz2 - visualization
        Node(
            package='rviz2',
            executable='rviz2',
            name='rviz2',
            output='screen'
        )
    ])
```

### Step 3: Run Visualization

```bash
source /opt/ros/humble/setup.bash
ros2 launch display_humanoid.launch.py
```

**What You'll See**:
1. RViz2 window with robot model
2. Joint State Publisher GUI with sliders for each joint
3. Move sliders to control neck and shoulder joints

### RViz2 Setup

In RViz2:
1. Add `RobotModel` display (Add → RobotModel)
2. Set Fixed Frame to `base_link`
3. Adjust viewpoint with mouse

---

## Visual vs Collision Geometry

### Visual Geometry
- **Purpose**: What you see (rendering)
- **Complexity**: Can be detailed meshes with high polygon count
- **Performance**: Only affects graphics rendering

### Collision Geometry
- **Purpose**: Physics simulation and collision detection
- **Complexity**: Should be simple (boxes, cylinders, spheres)
- **Performance**: Critical for simulation speed

### Best Practice

Use **detailed meshes** for visual, **simple shapes** for collision:

```xml
<link name="head">
  <!-- Visual: detailed 3D scan -->
  <visual>
    <geometry>
      <mesh filename="package://robot_description/meshes/head_detailed.stl"/>
    </geometry>
  </visual>

  <!-- Collision: simple sphere -->
  <collision>
    <geometry>
      <sphere radius="0.12"/>
    </geometry>
  </collision>
</link>
```

---

## Publishing Joint States

To animate your robot, publish joint positions:

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
import math


class JointStatePublisher(Node):
    def __init__(self):
        super().__init__('joint_state_publisher')

        self.publisher = self.create_publisher(JointState, 'joint_states', 10)
        self.timer = self.create_timer(0.05, self.publish_joint_states)  # 20 Hz

        self.angle = 0.0

    def publish_joint_states(self):
        msg = JointState()
        msg.header.stamp = self.get_clock().now().to_msg()

        # Joint names (must match URDF)
        msg.name = ['neck', 'left_shoulder', 'right_shoulder']

        # Animate: wave arms and turn head
        self.angle += 0.05
        msg.position = [
            math.sin(self.angle),              # Neck: -1 to 1 rad
            math.sin(self.angle) * 1.5,        # Left arm
            -math.sin(self.angle) * 1.5        # Right arm (opposite)
        ]

        msg.velocity = []
        msg.effort = []

        self.publisher.publish(msg)
        self.get_logger().info(f'Publishing joint states: neck={msg.position[0]:.2f}')


def main(args=None):
    rclpy.init(args=args)
    node = JointStatePublisher()
    rclpy.spin(node)


if __name__ == '__main__':
    main()
```

**Usage**:
1. Run `robot_state_publisher` with URDF
2. Run this script to animate joints
3. View in RViz2

---

## Practical Exercise: Add Forearms

**Task**: Extend the simple humanoid with forearms and elbow joints.

**Requirements**:
1. Add `left_forearm` and `right_forearm` links (cylinders, 0.25m length)
2. Add `left_elbow` and `right_elbow` revolute joints
3. Elbow range: 0 to 2.5 radians (0° to ~143°)
4. Attach forearms to lower end of upper arms

**Hints**:
- Origin of elbow joint: `xyz="0 0 -0.3"` (bottom of upper arm)
- Axis: `xyz="0 1 0"` (pitch rotation)
- Visual geometry origin: `xyz="0 0 -0.125"` (center of forearm)

**Testing**:
- Add forearms to URDF
- Launch visualization
- Use Joint State Publisher GUI to control elbows

---

## Common Humanoid Joint Configurations

### Neck (Head)
- **DOF**: 1-3 (yaw, pitch, roll)
- **Range**: ±90° yaw, ±45° pitch

### Shoulder
- **DOF**: 3 (pitch, roll, yaw)
- **Range**: Varies by axis (±180° pitch, ±90° roll)

### Elbow
- **DOF**: 1 (pitch only)
- **Range**: 0° to 150°

### Hip
- **DOF**: 3 (pitch, roll, yaw)
- **Range**: ±120° pitch, ±45° roll

### Knee
- **DOF**: 1 (pitch only)
- **Range**: 0° to 150°

### Ankle
- **DOF**: 2 (pitch, roll)
- **Range**: ±30° pitch, ±20° roll

---

## URDF Best Practices

**Naming Conventions**:
- Use descriptive names: `left_shoulder_pitch` not `joint_1`
- Prefix with side: `left_`, `right_`
- Suffix with motion: `_pitch`, `_roll`, `_yaw`

**Coordinate Frames**:
- Follow ROS convention: X forward, Y left, Z up
- Align joint axes consistently

**Mass and Inertia**:
- Use realistic values (human arm ~1.5-2kg)
- Calculate inertia for basic shapes
- Affects simulation stability

**Collision Geometry**:
- Keep simple for performance
- Slightly smaller than visual to avoid micro-collisions

**File Organization**:
```
robot_description/
├── urdf/
│   └── humanoid.urdf
├── meshes/
│   ├── torso.stl
│   └── head.obj
└── launch/
    └── display.launch.py
```

---

## Summary

**Key Takeaways**:

1. **URDF**: XML format for defining robot structure (links, joints, geometry)
2. **Links**: Rigid bodies with visual, collision, and inertial properties
3. **Joints**: Connections between links (fixed, revolute, prismatic, continuous)
4. **Visualization**: Use RViz2 with `robot_state_publisher` and `joint_state_publisher_gui`
5. **Best Practices**: Simple collision geometry, realistic inertia, clear naming
6. **Joint States**: Publish `JointState` messages to animate robot

**Next Module**: Module 2 will cover **Digital Twins** using Gazebo and Unity for physics simulation and realistic rendering.

---

## Troubleshooting

**Problem**: URDF doesn't display in RViz2

**Solutions**:
1. Check URDF syntax: `check_urdf simple_humanoid.urdf`
2. Verify Fixed Frame is set to `base_link` in RViz2
3. Add `RobotModel` display in RViz2
4. Check `robot_state_publisher` is running: `ros2 node list`

**Problem**: Joints don't move with Joint State Publisher GUI

**Solutions**:
1. Verify joint names in URDF
2. Check joint type is not `fixed`
3. Ensure `robot_state_publisher` is receiving joint states

**Problem**: Robot appears distorted or incorrect size

**Solutions**:
1. Check origin values in links (xyz positions)
2. Verify geometry sizes (meters, not millimeters)
3. Check mesh scale factors if using custom meshes

---

## Further Reading

- [URDF Tutorial](https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/URDF-Main.html)
- [URDF XML Specification](http://wiki.ros.org/urdf/XML)
- [RViz2 User Guide](https://docs.ros.org/en/humble/Tutorials/Intermediate/RViz/RViz-User-Guide/RViz-User-Guide.html)
- [Humanoid Robot Kinematics](https://ieeexplore.ieee.org/document/8968739)

---

**Module 1 Complete!** ✅ You've mastered ROS 2 fundamentals: nodes, topics, services, and URDF. Proceed to **Module 2: Digital Twin (Gazebo & Unity)** for physics simulation and realistic rendering.
